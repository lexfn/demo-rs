use hecs::World;
use imgui::Condition;

use crate::render::Ui;
use crate::scene::components::{Player, Transform};
use crate::state::AppState;

pub struct Hud;

// TODO Ideally every component should have the possibility to render something to the UI.
// So far I haven't been able to pass the `frame` reference around to allow for that,
// the the UI rendering code continues to be a "singleton". Maybe the UI rendering should be done
// as a list of commands generated by various components and then fed to the Ui component.
impl Hud {
    pub fn update(dt: f32, w: &mut World, state: &AppState, ui: &mut Ui) {
        let (_, (pl_tr,)) = w
            .query_mut::<(&Transform,)>()
            .with::<&Player>()
            .into_iter()
            .next()
            .unwrap();

        ui.prepare_frame(dt, &state.window, |frame| {
            let window = frame.window("Info");
            window
                .always_auto_resize(true)
                .size([300.0, 150.0], Condition::FirstUseEver)
                .position([20.0, 20.0], Condition::FirstUseEver)
                .build(|| {
                    frame.text("Controls:");
                    frame.text("Tab: capture/release mouse");
                    frame.text("WASDQE: move camera while mouse is captured");
                    frame.text("F: spawn a box");
                    frame.text("Left mouse click: grab/release an object");
                    frame.separator();
                    frame.text(format!("Using adapter {}", state.renderer.adapter_name));
                    frame.separator();
                    let mouse_pos = frame.io().mouse_pos;
                    // Sometimes the coordinates are reported as very big negative numbers, e.g.
                    // when the app just starts.
                    frame.text(format!(
                        "Mouse position: ({:.1},{:.1})",
                        if mouse_pos[0] >= 0f32 {
                            mouse_pos[0]
                        } else {
                            0f32
                        },
                        if mouse_pos[1] >= 0f32 {
                            mouse_pos[1]
                        } else {
                            0f32
                        }
                    ));
                    frame.text(format!("Frame time: {dt:?}"));
                    frame.text(format!(
                        "Player position: ({:.2}, {:.2}, {:.2})",
                        pl_tr.position().x,
                        pl_tr.position().y,
                        pl_tr.position().z
                    ));
                    frame.text(format!(
                        "Player rotation angles: ({:.2}, {:.2}, {:.2})",
                        pl_tr.rotation_angles().x,
                        pl_tr.rotation_angles().y,
                        pl_tr.rotation_angles().z
                    ));
                });
        })
    }
}
